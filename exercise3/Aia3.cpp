//============================================================================
// Name        : Aia3.cpp
// Author      : Ronny Haensch
// Version     : 1.0
// Copyright   : -
// Description :
//============================================================================

#include "Aia3.h"

// shows hough space, eg. as a projection of angle- and scale-dimensions down to a single image
/*
 houghSpace:	the hough space as generated by generalHough(..)
 */
void Aia3::plotHough(vector< vector<Mat> >& houghSpace){
    // TO DO !!!
}

// creates the fourier-spectrum of the scaled and rotated template
/*
 templ:	the object template; binary image in templ[0], complex gradient in templ[1]
 scale:	the scale factor to scale the template
 angle:	the angle to rotate the template
 fftMask:	the generated fourier-spectrum of the template (initialized outside of this function)
 */
void Aia3::makeFFTObjectMask(vector<Mat>& templ, double scale, double angle, Mat& fftMask){
    // TO DO !!!
}

// computes the hough space of the general hough transform
/*
 gradImage:	the gradient image of the test image
 templ:		the template consisting of binary image and complex-valued directional gradient image
 scaleSteps:	scale resolution
 scaleRange:	range of investigated scales [min, max]
 angleSteps:	angle resolution
 angleRange:	range of investigated angles [min, max)
 return:		the hough space: outer vector over scales, inner vector of angles
 */
vector< vector<Mat> > Aia3::generalHough(Mat& gradImage, vector<Mat>& templ, double scaleSteps, double* scaleRange, double angleSteps, double* angleRange){
    vector< vector<Mat> > hough;
    // TO DO !!!
    return hough;
}

// creates object template from template image
/*
 templateImage:	the template image
 sigma:			standard deviation of directional gradient kernel
 templateThresh:	threshold for binarization of the template image
 return:			the computed template
 */
vector<Mat> Aia3::makeObjectTemplate(Mat& templateImage, double sigma, double templateThresh){
    // TO DO !!!
    cout << "makeObjectTemplate() templateImage size: " << templateImage.size() << endl;
    cout << "makeObjectTemplate() templateImage type: " << templateImage.type() << endl; //type 5 = 32FC1
    showImage(templateImage, "templateImage", 0);
    
    // PART 1: BINARY EDGE MAP
    // obj: grayscale img -> b&w binary img
    // need threshold
    // erode for imgs with too much detail? to remove high frequencies
    Mat thresholdImage;
    double minVal, maxVal;
    minMaxLoc(templateImage, &minVal, &maxVal);
    threshold(templateImage, thresholdImage, templateThresh*maxVal, 255, THRESH_BINARY);
    cout << "makeObjectTemplate() thresholdImage type: " << thresholdImage.type() << endl; //type 5 = 32FC1
    thresholdImage.convertTo(thresholdImage, CV_8UC1); //so that compatible for findContours()
    showImage(thresholdImage, "thresholdImage", 0);
    
    // notes:
    // templateThres is a relative value... assumed relative to the image that it's thresholding
    // once that relativity was established, the noise from thresholdImage disappeared and the contours reduced from 16 to the correct 3
    // hence erodedImage no longer needed
        //Mat erodedImage;
        //erode(thresholdImage, erodedImage, Mat(), Point(-1,-1), 1);



    
    // obj: get edges/contours
    // edge detection vs findcontours
    // produce as Mat

//    vector<Mat> contourList;
//    findContours(thresholdImage, contourList, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE);
//    cout << "makeObjectTemplate() thresholdImage contourList size: " << contourList.size() << endl; //16 w/o erosion
//    int i = 0;
//    for (auto contour : contourList) { // auto to automatically determine object type
//        i++;
//        cout << "contour" << i << contour << endl;
//    }
    
    // the purpose of finding the contour points in ES2 was to perform DFT on those location values
    // this time, we don't need their location values, simply an image produced with the binary edges
    Mat binaryEdgeImage;
    Canny(thresholdImage, binaryEdgeImage, templateThresh*maxVal, templateThresh*maxVal*2, 3 );
    cout << "makeObjectTemplate() binaryEdgeImage type: " << binaryEdgeImage.type() << endl; //type 0 = 8UC1
    showImage(binaryEdgeImage, "binaryEdgeImage", 0);
    
    
    
    
    // PART 2: COMPLEX GRADIENT IMG
    // Mat calcDirectionalGrad(Mat& testImage, double sigma) is Vec2f
    Mat gradientImage = calcDirectionalGrad(templateImage, sigma);
    cout << "gradientImage" << endl;
    for (int i=0; i<gradientImage.size().height; i++) {
        for (int j=0; j<gradientImage.size().width; j++) {
            cout << gradientImage.at<Vec2f>(i,j) << endl;
        }
    }
    
    Mat gradients[2];
    split(gradientImage, gradients);
    showImage(gradients[0], "gradient x", 0);
    showImage(gradients[1], "gradient y", 0);

    
    // PART 3: add the Mat's to vector<Mat>
    vector<Mat> resultVector;
    resultVector.push_back(binaryEdgeImage);
    resultVector.push_back(gradientImage);

    
    return resultVector;
}

/* *****************************
 GIVEN FUNCTIONS
 ***************************** */

// loads template and test images, sets parameters and calls processing routine
/*
 tmplImg:	path to template image
 testImg:	path to test image
 */
void Aia3::run(string tmplImg, string testImg){
    
    // processing parameter
    double sigma 			= 1;		// standard deviation of directional gradient kernel
    double templateThresh 	= 0.3;		// relative threshold for binarization of the template image
    // TO DO !!!
    // ****
    // Set parameters to reasonable values
    double objThresh 		= 0;		// relative threshold for maxima in hough space
    double scaleSteps 		= 1;		// scale resolution in terms of number of scales to be investigated
    double scaleRange[2];				// scale of angles [min, max]
    scaleRange[0] 			= 1;
    scaleRange[1] 			= 1;
    double angleSteps 		= 1;		// angle resolution in terms of number of angles to be investigated
    double angleRange[2];				// range of angles [min, max)
    angleRange[0] 			= 0;
    angleRange[1] 			= 0;
    // ****
    
    Mat params = (Mat_<float>(1,9) << sigma, templateThresh, objThresh, scaleSteps, scaleRange[0], scaleRange[1], angleSteps, angleRange[0], angleRange[1]);
    
    // load template image as gray-scale, paths in argv[1]
    Mat templateImage = imread( tmplImg, 0);
    if (!templateImage.data){
        cerr << "ERROR: Cannot load template image from\n" << tmplImg << endl;
        cerr << "Press enter..." << endl;
        cin.get();
        exit(-1);
    }
    // convert 8U to 32F
    cout << "templateImage type" << templateImage.type() << endl;
    templateImage.convertTo(templateImage, CV_32FC1);
    // show template image
    showImage(templateImage, "Template image", 0);
    
    // load test image
    Mat testImage = imread( testImg, 0);
    if (!testImage.data){
        cerr << "ERROR: Cannot load test image from\n" << testImg << endl;
        cerr << "Press enter..." << endl;
        cin.get();
        exit(-1);
    }
    // and convert it from 8U to 32F
    cout << "testImage type" << testImage.type() << endl;
    testImage.convertTo(testImage, CV_32FC1);
    // show test image
    showImage(testImage, "testImage", 0);
    
    // start processing
    process(templateImage, testImage, params);
    
}

// loads template and create test image, sets parameters and calls processing routine
/*
 tmplImg:	path to template image
 angle:		rotation angle in degree of the test object
 scale:		scale of the test object
 */
void Aia3::test(string tmplImg, float angle, float scale){
    
    // angle to rotate template image (in radian)
    double testAngle = angle/180.*CV_PI;
    // scale to scale template image
    double testScale = scale;
    
    // processing parameter
    double sigma 			= 1;		// standard deviation of directional gradient kernel
    double templateThresh 	= 0.7;		// relative threshold for binarization of the template image
    double objThresh		= 0.85;		// relative threshold for maxima in hough space
    double scaleSteps 		= 3;		// scale resolution in terms of number of scales to be investigated
    double scaleRange[2];				// scale of angles [min, max]
    scaleRange[0] 			= 1;
    scaleRange[1] 			= 2;
    double angleSteps 		= 12;		// angle resolution in terms of number of angles to be investigated
    double angleRange[2];				// range of angles [min, max)
    angleRange[0] 			= 0;
    angleRange[1] 			= 2*CV_PI;
    
    Mat params = (Mat_<float>(1,9) << sigma, templateThresh, objThresh, scaleSteps, scaleRange[0], scaleRange[1], angleSteps, angleRange[0], angleRange[1]);
		  
    // load template image as gray-scale, paths in argv[1]
    Mat templateImage = imread( tmplImg, 0);
    if (!templateImage.data){
        cerr << "ERROR: Cannot load template image from\n" << tmplImg << endl;
        cerr << "Press enter..." << endl;
        cin.get();
        exit(-1);
    }
    // convert 8U to 32F
    // cout << "templateImage type" << templateImage.type() << endl;
    templateImage.convertTo(templateImage, CV_32FC1); //originally type0 8UC1
    // show template image
    showImage(templateImage, "Template Image", 0);
    
    // generate test image
    Mat testImage = makeTestImage(templateImage, testAngle, testScale, scaleRange);
    // show test image
    showImage(testImage, "Test Image", 0);
    
    // start processing
    process(templateImage, testImage, params);
}

void Aia3::process(Mat& templateImage, Mat& testImage, Mat& params){
    
    // processing parameter
    double sigma			= params.at<float>(0);		// standard deviation of directional gradient kernel
    double templateThresh 	= params.at<float>(1);		// relative threshold for binarization of the template image
    double objThresh 		= params.at<float>(2);		// relative threshold for maxima in hough space
    double scaleSteps 		= params.at<float>(3);		// scale resolution in terms of number of scales to be investigated
    double scaleRange[2];								// scale of angles [min, max]
    scaleRange[0] 			= params.at<float>(4);
    scaleRange[1] 			= params.at<float>(5);
    double angleSteps 		= params.at<float>(6);		// angle resolution in terms of number of angles to be investigated
    double angleRange[2];								// range of angles [min, max)
    angleRange[0] 			= params.at<float>(7);
    angleRange[1] 			= params.at<float>(8);
    
    // calculate directional gradient of test image as complex numbers (two channel image)
    Mat gradImage = calcDirectionalGrad(testImage, sigma);
    
    // generate template from template image
    // templ[0] == binary image
    // templ[0] == directional gradient image
    vector<Mat> templ = makeObjectTemplate(templateImage, sigma, templateThresh);
    
    // show binary image
    showImage(templ[0], "Binary part of template", 0);
    
    // perfrom general hough transformation
    vector< vector<Mat> > houghSpace = generalHough(gradImage, templ, scaleSteps, scaleRange, angleSteps, angleRange);
    
    // plot hough space (max over angle- and scale-dimension)
    plotHough(houghSpace);
    
    // find maxima in hough space
    vector<Scalar> objList;
    findHoughMaxima(houghSpace, objThresh, objList);
    
    // print found objects on screen
    cout << "Number of objects: " << objList.size() << endl;
    int i=0;
    for(vector<Scalar>::iterator it = objList.begin(); it != objList.end(); it++, i++){
        cout << i << "\tScale:\t" << (scaleRange[1] - scaleRange[0])/(scaleSteps-1)*(*it).val[0] + scaleRange[0];
        cout << "\tAngle:\t" << ((angleRange[1] - angleRange[0])/(angleSteps)*(*it).val[1] + angleRange[0])/CV_PI*180;
        cout << "\tPosition:\t(" << (*it).val[2] << ", " << (*it).val[3] << " )" << endl;
    }
    
    // show final detection result
    plotHoughDetectionResult(testImage, templ, objList, scaleSteps, scaleRange, angleSteps, angleRange);
    
}
// computes directional gradients
/*
 image:	the input image
 sigma:	standard deviation of the kernel
 return:	the two-channel gradient image
 */
Mat Aia3::calcDirectionalGrad(Mat& image, double sigma){
    
    // compute kernel size
    int ksize = max(sigma*3,3.);
    if (ksize % 2 == 0)  ksize++;
    double mu = ksize/2.0;
    
    // generate kernels for x- and y-direction
    double val, sum=0;
    Mat kernel(ksize, ksize, CV_32FC1);
    //Mat kernel_y(ksize, ksize, CV_32FC1);
    for(int i=0; i<ksize; i++){
        for(int j=0; j<ksize; j++){
            val  = pow((i+0.5-mu)/sigma,2);
            val += pow((j+0.5-mu)/sigma,2);
            val = exp(-0.5*val);
            sum += val;
            kernel.at<float>(i, j) = -(j+0.5-mu)*val;
        }
    }
    kernel /= sum;
    // use those kernels to compute gradient in x- and y-direction independently
    vector<Mat> grad(2);
    filter2D(image, grad[0], -1, kernel);
    filter2D(image, grad[1], -1, kernel.t());
    // combine both real-valued gradient images to a single complex-valued image
    Mat output;
    merge(grad, output);
    
    return output;
}

// rotates and scales a given image
/*
 image:	the image to be scaled and rotated
 angle:	rotation angle in radians
 scale:	scaling factor
 return:	transformed image
 */
Mat Aia3::rotateAndScale(Mat& image, double angle, double scale){
    
    // create transformation matrices
    // translation to origin
    Mat T = Mat::eye(3, 3, CV_32FC1);
    T.at<float>(0, 2) = -image.cols/2.0;
    T.at<float>(1, 2) = -image.rows/2.0;
    // rotation
    Mat R = Mat::eye(3, 3, CV_32FC1);
    R.at<float>(0, 0) =  cos(angle);
    R.at<float>(0, 1) = -sin(angle);
    R.at<float>(1, 0) =  sin(angle);
    R.at<float>(1, 1) =  cos(angle);
    // scale
    Mat S = Mat::eye(3, 3, CV_32FC1);
    S.at<float>(0, 0) = scale;
    S.at<float>(1, 1) = scale;
    // combine
    Mat H = R*S*T;
    
    // compute corners of warped image
    Mat corners(1, 4, CV_32FC2);
    corners.at<Vec2f>(0, 0) = Vec2f(0,0);
    corners.at<Vec2f>(0, 1) = Vec2f(0,image.rows);
    corners.at<Vec2f>(0, 2) = Vec2f(image.cols,0);
    corners.at<Vec2f>(0, 3) = Vec2f(image.cols,image.rows);
    perspectiveTransform(corners, corners, H);
    
    // compute size of resulting image and allocate memory
    float x_start = min( min( corners.at<Vec2f>(0, 0)[0], corners.at<Vec2f>(0, 1)[0]), min( corners.at<Vec2f>(0, 2)[0], corners.at<Vec2f>(0, 3)[0]) );
    float x_end   = max( max( corners.at<Vec2f>(0, 0)[0], corners.at<Vec2f>(0, 1)[0]), max( corners.at<Vec2f>(0, 2)[0], corners.at<Vec2f>(0, 3)[0]) );
    float y_start = min( min( corners.at<Vec2f>(0, 0)[1], corners.at<Vec2f>(0, 1)[1]), min( corners.at<Vec2f>(0, 2)[1], corners.at<Vec2f>(0, 3)[1]) );
    float y_end   = max( max( corners.at<Vec2f>(0, 0)[1], corners.at<Vec2f>(0, 1)[1]), max( corners.at<Vec2f>(0, 2)[1], corners.at<Vec2f>(0, 3)[1]) );
    
    // create translation matrix in order to copy new object to image center
    T.at<float>(0, 0) = 1;
    T.at<float>(1, 1) = 1;
    T.at<float>(2, 2) = 1;
    T.at<float>(0, 2) = (x_end - x_start + 1)/2.0;
    T.at<float>(1, 2) = (y_end - y_start + 1)/2.0;
    
    // change homography to take necessary translation into account
    H = T * H;
    // warp image and copy it to output image
    Mat output;
    warpPerspective(image, output, H, Size(x_end - x_start + 1, y_end - y_start + 1), CV_INTER_LINEAR);
    
    return output;
    
}

// generates the test image as a transformed version of the template image
/*
 temp:		the template image
 angle:	rotation angle
 scale:	scaling factor
 scaleRange:	scale range [min,max], used to determine the image size
 */
Mat Aia3::makeTestImage(Mat& temp, double angle, double scale, double* scaleRange){
    
    // rotate and scale template image
    Mat small = rotateAndScale(temp, angle, scale);
    
    // create empty test image
    Mat testImage = Mat::zeros(temp.rows*scaleRange[1]*2, temp.cols*scaleRange[1]*2, CV_32FC1);
    // copy new object into test image
    Mat tmp;
    Rect roi;
    roi = Rect( (testImage.cols - small.cols)*0.5, (testImage.rows - small.rows)*0.5, small.cols, small.rows);
    tmp = Mat(testImage, roi);
    small.copyTo(tmp);
    
    return testImage;
}

// shows the detection result of the hough transformation
/*
 testImage:	the test image, where objects were searched (and hopefully found)
 templ:		the template consisting of binary image and complex-valued directional gradient image
 objList:		list of objects as defined by findHoughMaxima(..)
 scaleSteps:	scale resolution
 scaleRange:	range of investigated scales [min, max]
 angleSteps:	angle resolution
 angleRange:	range of investigated angles [min, max)
 */
void Aia3::plotHoughDetectionResult(Mat& testImage, vector<Mat>& templ, vector<Scalar>& objList, double scaleSteps, double* scaleRange, double angleSteps, double* angleRange){
    
    // some matrices to deal with color
    Mat red = testImage.clone();
    Mat green = testImage.clone();
    Mat blue = testImage.clone();
    Mat tmp = Mat::zeros(testImage.rows, testImage.cols, CV_32FC1);
    
    // scale and angle of current object
    double scale, angle;
    
    // for all objects
    for(vector<Scalar>::iterator it = objList.begin(); it != objList.end(); it++){
        // compute scale and angle of current object
        scale = (scaleRange[1] - scaleRange[0])/(scaleSteps-1)*(*it).val[0] + scaleRange[0];
        angle = ((angleRange[1] - angleRange[0])/(angleSteps)*(*it).val[1] + angleRange[0]);
        
        // use scale and angle in order to generate new binary mask of template
        Mat binMask = rotateAndScale(templ[0], angle, scale);
        
        // perform boundary checks
        Rect binArea = Rect(0, 0, binMask.cols, binMask.rows);
        Rect imgArea = Rect((*it).val[2]-binMask.cols/2., (*it).val[3]-binMask.rows/2, binMask.cols, binMask.rows);
        if ( (*it).val[2]-binMask.cols/2 < 0 ){
            binArea.x = abs( (*it).val[2]-binMask.cols/2 );
            binArea.width = binMask.cols - binArea.x;
            imgArea.x = 0;
            imgArea.width = binArea.width;
        }
        if ( (*it).val[3]-binMask.rows/2 < 0 ){
            binArea.y = abs( (*it).val[3]-binMask.rows/2 );
            binArea.height = binMask.rows - binArea.y;
            imgArea.y = 0;
            imgArea.height = binArea.height;
        }
        if ( (*it).val[2]-binMask.cols/2 + binMask.cols >= tmp.cols ){
            binArea.width = binMask.cols - ( (*it).val[2]-binMask.cols/2 + binMask.cols - tmp.cols );
            imgArea.width = binArea.width;
        }
        if ( (*it).val[3]-binMask.rows/2 + binMask.rows >= tmp.rows ){
            binArea.height = binMask.rows - ( (*it).val[3]-binMask.rows/2 + binMask.rows - tmp.rows );
            imgArea.height = binArea.height;
        }
        // copy this object instance in new image of correct size
        tmp.setTo(0);
        Mat binRoi = Mat(binMask, binArea);
        Mat imgRoi = Mat(tmp, imgArea);
        binRoi.copyTo(imgRoi);
        
        // delete found object from original image in order to reset pixel values with red (which are white up until now)
        binMask = 1 - binMask;
        imgRoi = Mat(red, imgArea);
        multiply(imgRoi, binRoi, imgRoi);
        imgRoi = Mat(green, imgArea);
        multiply(imgRoi, binRoi, imgRoi);
        imgRoi = Mat(blue, imgArea);
        multiply(imgRoi, binRoi, imgRoi);
        
        // change red channel
        red = red + tmp*255;
    }
    // generate color image
    vector<Mat> color;
    color.push_back(blue);
    color.push_back(green);
    color.push_back(red);
    Mat display;
    merge(color, display);
    // display color image
    showImage(display, "result", 0);
    // save color image
    imwrite("detectionResult.png", display);
}

// seeks for local maxima within the hough space
/*
 a local maxima has to be larger than all its 8 spatial neighbors, as well as the largest value at this position for all scales and orientations
 houghSpace:	the computed hough space
 objThresh:	relative threshold for maxima in hough space
 objList:	list of detected objects
 */
void Aia3::findHoughMaxima(vector< vector<Mat> >& houghSpace, double objThresh, vector<Scalar>& objList){
    
    // get maxima over scales and angles
    Mat maxImage = Mat::zeros(houghSpace.at(0).at(0).rows, houghSpace.at(0).at(0).cols, CV_32FC1 );
    for(vector< vector<Mat> >::iterator it = houghSpace.begin(); it != houghSpace.end(); it++){
        for(vector<Mat>::iterator img = (*it).begin(); img != (*it).end(); img++){
            max(*img, maxImage, maxImage);
        }
    }
    // get global maxima
    double min, max;
    minMaxLoc(maxImage, &min, &max);
    
    // define threshold
    double threshold = objThresh * max;
    
    // spatial non-maxima suppression
    Mat bin = Mat(houghSpace.at(0).at(0).rows, houghSpace.at(0).at(0).cols, CV_32FC1, -1);
    for(int y=0; y<maxImage.rows; y++){
        for(int x=0; x<maxImage.cols; x++){
            // init
            bool localMax = true;
            // check neighbors
            for(int i=-1; i<=1; i++){
                int new_y = y + i;
                if ((new_y < 0) or (new_y >= maxImage.rows)){
                    continue;
                }
                for(int j=-1; j<=1; j++){
                    int new_x = x + j;
                    if ((new_x < 0) or (new_x >= maxImage.cols)){
                        continue;
                    }
                    if (maxImage.at<float>(new_y, new_x) > maxImage.at<float>(y, x)){
                        localMax = false;
                        break;
                    }
                }
                if (!localMax)
                    break;
            }
            // check if local max is larger than threshold
            if ( (localMax) and (maxImage.at<float>(y, x) > threshold) ){
                bin.at<float>(y, x) = maxImage.at<float>(y, x);
            }
        }
    }
    
    // loop through hough space after non-max suppression and add objects to object list
    double scale, angle;
    scale = 0;
    for(vector< vector<Mat> >::iterator it = houghSpace.begin(); it != houghSpace.end(); it++, scale++){
        angle = 0;
        for(vector<Mat>::iterator img = (*it).begin(); img != (*it).end(); img++, angle++){
            for(int y=0; y<bin.rows; y++){
                for(int x=0; x<bin.cols; x++){
                    if ( (*img).at<float>(y, x) == bin.at<float>(y, x) ){
                        // create object list entry consisting of scale, angle, and position where object was detected
                        Scalar cur;
                        cur.val[0] = scale;
                        cur.val[1] = angle;
                        cur.val[2] = x;
                        cur.val[3] = y;
                        objList.push_back(cur);
                    }
                }
            }
        }
    }
}

// shows the image
/*
 img:	the image to be displayed
 win:	the window name
 dur:	wait number of ms or until key is pressed
 */
void Aia3::showImage(Mat& img, string win, double dur){
    
    // use copy for normalization
    Mat tempDisplay;
    if (img.channels() == 1)
        normalize(img, tempDisplay, 0, 255, CV_MINMAX);
    else
        tempDisplay = img.clone();
    
    tempDisplay.convertTo(tempDisplay, CV_8UC1);
    
    // create window and display omage
    namedWindow( win.c_str(), 0 );
    imshow( win.c_str(), tempDisplay );
    // wait
    if (dur>=0) cvWaitKey(dur);
    // be tidy
    destroyWindow(win.c_str());
    
}

// Performes a circular shift in (dx,dy) direction
/*
 in:		input matrix
 out:	circular shifted matrix
 dx:		shift in x-direction
 dy:		shift in y-direction
 */
void Aia3::circShift(Mat& in, Mat& out, int dx, int dy){
    
    Mat tmp = Mat::zeros(in.rows, in.cols, in.type());
    
    int x, y, new_x, new_y;
    
    for(y=0; y<in.rows; y++){
        
        // calulate new y-coordinate
        new_y = y + dy;
        if (new_y<0)
            new_y = new_y + in.rows;
        if (new_y>=in.rows)
            new_y = new_y - in.rows;
        
        for(x=0; x<in.cols; x++){
            
            // calculate new x-coordinate
            new_x = x + dx;
            if (new_x<0)
                new_x = new_x + in.cols;
            if (new_x>=in.cols)
                new_x = new_x - in.cols;
            
            tmp.at<Vec2f>(new_y, new_x) = in.at<Vec2f>(y, x);
            
        }
    }
    out = tmp;
}
